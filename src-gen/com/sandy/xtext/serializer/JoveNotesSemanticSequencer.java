/*
 * generated by Xtext
 */
package com.sandy.xtext.serializer;

import com.google.inject.Inject;
import com.sandy.xtext.joveNotes.CMap;
import com.sandy.xtext.joveNotes.ChapterDetails;
import com.sandy.xtext.joveNotes.ChapterSection;
import com.sandy.xtext.joveNotes.ChemCompound;
import com.sandy.xtext.joveNotes.ChemEquation;
import com.sandy.xtext.joveNotes.CompilerBreak;
import com.sandy.xtext.joveNotes.Definition;
import com.sandy.xtext.joveNotes.EqSymbol;
import com.sandy.xtext.joveNotes.Equation;
import com.sandy.xtext.joveNotes.EvalVar;
import com.sandy.xtext.joveNotes.Event;
import com.sandy.xtext.joveNotes.Exercise;
import com.sandy.xtext.joveNotes.FIB;
import com.sandy.xtext.joveNotes.HotSpot;
import com.sandy.xtext.joveNotes.ImageLabel;
import com.sandy.xtext.joveNotes.JoveNotes;
import com.sandy.xtext.joveNotes.JoveNotesPackage;
import com.sandy.xtext.joveNotes.MatchMCQConfig;
import com.sandy.xtext.joveNotes.MatchPair;
import com.sandy.xtext.joveNotes.Matching;
import com.sandy.xtext.joveNotes.MultiChoice;
import com.sandy.xtext.joveNotes.Option;
import com.sandy.xtext.joveNotes.ProcessingHints;
import com.sandy.xtext.joveNotes.QuestionAnswer;
import com.sandy.xtext.joveNotes.RefToContext;
import com.sandy.xtext.joveNotes.Script;
import com.sandy.xtext.joveNotes.ScriptBody;
import com.sandy.xtext.joveNotes.Spellbee;
import com.sandy.xtext.joveNotes.TeacherNote;
import com.sandy.xtext.joveNotes.TrueFalse;
import com.sandy.xtext.joveNotes.VoiceToText;
import com.sandy.xtext.joveNotes.WordMeaning;
import com.sandy.xtext.services.JoveNotesGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class JoveNotesSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private JoveNotesGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == JoveNotesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case JoveNotesPackage.CMAP:
				sequence_CMap(context, (CMap) semanticObject); 
				return; 
			case JoveNotesPackage.CHAPTER_DETAILS:
				sequence_ChapterDetails(context, (ChapterDetails) semanticObject); 
				return; 
			case JoveNotesPackage.CHAPTER_SECTION:
				if (rule == grammarAccess.getChapterSectionRule()) {
					sequence_ChapterSection(context, (ChapterSection) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNotesElementRule()) {
					sequence_ChapterSection_NotesElement(context, (ChapterSection) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.CHARACTER:
				if (rule == grammarAccess.getCharacterRule()
						|| rule == grammarAccess.getRTCElementRule()) {
					sequence_Character(context, (com.sandy.xtext.joveNotes.Character) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNotesElementRule()) {
					sequence_Character_NotesElement(context, (com.sandy.xtext.joveNotes.Character) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.CHEM_COMPOUND:
				if (rule == grammarAccess.getChemCompoundRule()
						|| rule == grammarAccess.getRTCElementRule()) {
					sequence_ChemCompound(context, (ChemCompound) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNotesElementRule()) {
					sequence_ChemCompound_NotesElement(context, (ChemCompound) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.CHEM_EQUATION:
				if (rule == grammarAccess.getChemEquationRule()
						|| rule == grammarAccess.getRTCElementRule()) {
					sequence_ChemEquation(context, (ChemEquation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNotesElementRule()) {
					sequence_ChemEquation_NotesElement(context, (ChemEquation) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.COMPILER_BREAK:
				if (rule == grammarAccess.getCompilerBreakRule()) {
					sequence_CompilerBreak(context, (CompilerBreak) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNotesElementRule()) {
					sequence_CompilerBreak_NotesElement(context, (CompilerBreak) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.DEFINITION:
				if (rule == grammarAccess.getDefinitionRule()
						|| rule == grammarAccess.getRTCElementRule()) {
					sequence_Definition(context, (Definition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNotesElementRule()) {
					sequence_Definition_NotesElement(context, (Definition) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.EQ_SYMBOL:
				sequence_EqSymbol(context, (EqSymbol) semanticObject); 
				return; 
			case JoveNotesPackage.EQUATION:
				if (rule == grammarAccess.getEquationRule()
						|| rule == grammarAccess.getRTCElementRule()) {
					sequence_Equation(context, (Equation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNotesElementRule()) {
					sequence_Equation_NotesElement(context, (Equation) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.EVAL_VAR:
				sequence_EvalVar(context, (EvalVar) semanticObject); 
				return; 
			case JoveNotesPackage.EVENT:
				if (rule == grammarAccess.getEventRule()
						|| rule == grammarAccess.getRTCElementRule()) {
					sequence_Event(context, (Event) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNotesElementRule()) {
					sequence_Event_NotesElement(context, (Event) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.EXERCISE:
				if (rule == grammarAccess.getExerciseRule()) {
					sequence_Exercise(context, (Exercise) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNotesElementRule()) {
					sequence_Exercise_NotesElement(context, (Exercise) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.FIB:
				if (rule == grammarAccess.getFIBRule()
						|| rule == grammarAccess.getRTCElementRule()) {
					sequence_FIB(context, (FIB) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNotesElementRule()) {
					sequence_FIB_NotesElement(context, (FIB) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.HOT_SPOT:
				sequence_HotSpot(context, (HotSpot) semanticObject); 
				return; 
			case JoveNotesPackage.IMAGE_LABEL:
				if (rule == grammarAccess.getImageLabelRule()
						|| rule == grammarAccess.getRTCElementRule()) {
					sequence_ImageLabel(context, (ImageLabel) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNotesElementRule()) {
					sequence_ImageLabel_NotesElement(context, (ImageLabel) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.JOVE_NOTES:
				sequence_JoveNotes(context, (JoveNotes) semanticObject); 
				return; 
			case JoveNotesPackage.MATCH_MCQ_CONFIG:
				sequence_MatchMCQConfig(context, (MatchMCQConfig) semanticObject); 
				return; 
			case JoveNotesPackage.MATCH_PAIR:
				sequence_MatchPair(context, (MatchPair) semanticObject); 
				return; 
			case JoveNotesPackage.MATCHING:
				if (rule == grammarAccess.getMatchingRule()
						|| rule == grammarAccess.getRTCElementRule()) {
					sequence_Matching(context, (Matching) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNotesElementRule()) {
					sequence_Matching_NotesElement(context, (Matching) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.MULTI_CHOICE:
				if (rule == grammarAccess.getRTCElementRule()
						|| rule == grammarAccess.getMultiChoiceRule()) {
					sequence_MultiChoice(context, (MultiChoice) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNotesElementRule()) {
					sequence_MultiChoice_NotesElement(context, (MultiChoice) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.OPTION:
				sequence_Option(context, (Option) semanticObject); 
				return; 
			case JoveNotesPackage.PROCESSING_HINTS:
				sequence_ProcessingHints(context, (ProcessingHints) semanticObject); 
				return; 
			case JoveNotesPackage.QUESTION_ANSWER:
				if (rule == grammarAccess.getNotesElementRule()) {
					sequence_NotesElement_QuestionAnswer(context, (QuestionAnswer) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getQuestionAnswerRule()
						|| rule == grammarAccess.getRTCElementRule()) {
					sequence_QuestionAnswer(context, (QuestionAnswer) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.REF_TO_CONTEXT:
				if (rule == grammarAccess.getNotesElementRule()) {
					sequence_NotesElement_RefToContext(context, (RefToContext) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRefToContextRule()) {
					sequence_RefToContext(context, (RefToContext) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.SCRIPT:
				sequence_Script(context, (Script) semanticObject); 
				return; 
			case JoveNotesPackage.SCRIPT_BODY:
				sequence_ScriptBody(context, (ScriptBody) semanticObject); 
				return; 
			case JoveNotesPackage.SPELLBEE:
				if (rule == grammarAccess.getNotesElementRule()) {
					sequence_NotesElement_Spellbee(context, (Spellbee) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSpellbeeRule()) {
					sequence_Spellbee(context, (Spellbee) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.TEACHER_NOTE:
				if (rule == grammarAccess.getNotesElementRule()) {
					sequence_NotesElement_TeacherNote(context, (TeacherNote) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTeacherNoteRule()
						|| rule == grammarAccess.getRTCElementRule()) {
					sequence_TeacherNote(context, (TeacherNote) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.TRUE_FALSE:
				if (rule == grammarAccess.getNotesElementRule()) {
					sequence_NotesElement_TrueFalse(context, (TrueFalse) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTrueFalseRule()
						|| rule == grammarAccess.getRTCElementRule()) {
					sequence_TrueFalse(context, (TrueFalse) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.VOICE_TO_TEXT:
				if (rule == grammarAccess.getNotesElementRule()) {
					sequence_NotesElement_VoiceToText(context, (VoiceToText) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVoiceToTextRule()) {
					sequence_VoiceToText(context, (VoiceToText) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.WORD_MEANING:
				if (rule == grammarAccess.getNotesElementRule()) {
					sequence_NotesElement_WordMeaning(context, (WordMeaning) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getWordMeaningRule()
						|| rule == grammarAccess.getRTCElementRule()) {
					sequence_WordMeaning(context, (WordMeaning) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     CMap returns CMap
	 *
	 * Constraint:
	 *     content=STRING
	 */
	protected void sequence_CMap(ISerializationContext context, CMap semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.CMAP__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.CMAP__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCMapAccess().getContentSTRINGTerminalRuleCall_2_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ChapterDetails returns ChapterDetails
	 *
	 * Constraint:
	 *     (
	 *         exerciseBank='@exercise_bank'? 
	 *         subjectName=STRING 
	 *         chapterNumber=INT 
	 *         subChapterNumber=INT 
	 *         chapterName=STRING 
	 *         scriptBody=ScriptBody?
	 *     )
	 */
	protected void sequence_ChapterDetails(ISerializationContext context, ChapterDetails semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ChapterSection returns ChapterSection
	 *
	 * Constraint:
	 *     sectionName=STRING
	 */
	protected void sequence_ChapterSection(ISerializationContext context, ChapterSection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.CHAPTER_SECTION__SECTION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.CHAPTER_SECTION__SECTION_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChapterSectionAccess().getSectionNameSTRINGTerminalRuleCall_1_0(), semanticObject.getSectionName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns ChapterSection
	 *
	 * Constraint:
	 *     (sectionName=STRING script=Script?)
	 */
	protected void sequence_ChapterSection_NotesElement(ISerializationContext context, ChapterSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Character returns Character
	 *     RTCElement returns Character
	 *
	 * Constraint:
	 *     (hideFromView='hide'? character=STRING estimate=STRING cmap=CMap?)
	 */
	protected void sequence_Character(ISerializationContext context, com.sandy.xtext.joveNotes.Character semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns Character
	 *
	 * Constraint:
	 *     (hideFromView='hide'? character=STRING estimate=STRING cmap=CMap? script=Script?)
	 */
	protected void sequence_Character_NotesElement(ISerializationContext context, com.sandy.xtext.joveNotes.Character semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ChemCompound returns ChemCompound
	 *     RTCElement returns ChemCompound
	 *
	 * Constraint:
	 *     (hideFromView='hide'? symbol=STRING chemicalName=STRING commonName=STRING?)
	 */
	protected void sequence_ChemCompound(ISerializationContext context, ChemCompound semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns ChemCompound
	 *
	 * Constraint:
	 *     (hideFromView='hide'? symbol=STRING chemicalName=STRING commonName=STRING? script=Script?)
	 */
	protected void sequence_ChemCompound_NotesElement(ISerializationContext context, ChemCompound semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ChemEquation returns ChemEquation
	 *     RTCElement returns ChemEquation
	 *
	 * Constraint:
	 *     (hideFromView='hide'? description=STRING? reactants=STRING produces=STRING? products=STRING)
	 */
	protected void sequence_ChemEquation(ISerializationContext context, ChemEquation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns ChemEquation
	 *
	 * Constraint:
	 *     (
	 *         hideFromView='hide'? 
	 *         description=STRING? 
	 *         reactants=STRING 
	 *         produces=STRING? 
	 *         products=STRING 
	 *         script=Script?
	 *     )
	 */
	protected void sequence_ChemEquation_NotesElement(ISerializationContext context, ChemEquation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompilerBreak returns CompilerBreak
	 *
	 * Constraint:
	 *     {CompilerBreak}
	 */
	protected void sequence_CompilerBreak(ISerializationContext context, CompilerBreak semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns CompilerBreak
	 *
	 * Constraint:
	 *     script=Script?
	 */
	protected void sequence_CompilerBreak_NotesElement(ISerializationContext context, CompilerBreak semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Definition
	 *     RTCElement returns Definition
	 *
	 * Constraint:
	 *     (hideFromView='hide'? term=STRING definition=STRING cmap=CMap?)
	 */
	protected void sequence_Definition(ISerializationContext context, Definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns Definition
	 *
	 * Constraint:
	 *     (hideFromView='hide'? term=STRING definition=STRING cmap=CMap? script=Script?)
	 */
	protected void sequence_Definition_NotesElement(ISerializationContext context, Definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EqSymbol returns EqSymbol
	 *
	 * Constraint:
	 *     (symbol=STRING description=STRING)
	 */
	protected void sequence_EqSymbol(ISerializationContext context, EqSymbol semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.EQ_SYMBOL__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.EQ_SYMBOL__SYMBOL));
			if (transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.EQ_SYMBOL__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.EQ_SYMBOL__DESCRIPTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqSymbolAccess().getSymbolSTRINGTerminalRuleCall_0_0(), semanticObject.getSymbol());
		feeder.accept(grammarAccess.getEqSymbolAccess().getDescriptionSTRINGTerminalRuleCall_2_0(), semanticObject.getDescription());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Equation returns Equation
	 *     RTCElement returns Equation
	 *
	 * Constraint:
	 *     (hideFromView='hide'? equation=STRING description=STRING? symbols+=EqSymbol symbols+=EqSymbol*)
	 */
	protected void sequence_Equation(ISerializationContext context, Equation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns Equation
	 *
	 * Constraint:
	 *     (
	 *         hideFromView='hide'? 
	 *         equation=STRING 
	 *         description=STRING? 
	 *         symbols+=EqSymbol 
	 *         symbols+=EqSymbol* 
	 *         script=Script?
	 *     )
	 */
	protected void sequence_Equation_NotesElement(ISerializationContext context, Equation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EvalVar returns EvalVar
	 *
	 * Constraint:
	 *     (varName=STRING varExpression=STRING)
	 */
	protected void sequence_EvalVar(ISerializationContext context, EvalVar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.EVAL_VAR__VAR_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.EVAL_VAR__VAR_NAME));
			if (transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.EVAL_VAR__VAR_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.EVAL_VAR__VAR_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEvalVarAccess().getVarNameSTRINGTerminalRuleCall_0_0(), semanticObject.getVarName());
		feeder.accept(grammarAccess.getEvalVarAccess().getVarExpressionSTRINGTerminalRuleCall_2_0(), semanticObject.getVarExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Event returns Event
	 *     RTCElement returns Event
	 *
	 * Constraint:
	 *     (hideFromView='hide'? event=STRING time=STRING)
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns Event
	 *
	 * Constraint:
	 *     (hideFromView='hide'? event=STRING time=STRING script=Script?)
	 */
	protected void sequence_Event_NotesElement(ISerializationContext context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Exercise returns Exercise
	 *
	 * Constraint:
	 *     (hideFromView='hide'? marks=INT question=STRING hints+=STRING* answer=STRING)
	 */
	protected void sequence_Exercise(ISerializationContext context, Exercise semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns Exercise
	 *
	 * Constraint:
	 *     (
	 *         hideFromView='hide'? 
	 *         marks=INT 
	 *         question=STRING 
	 *         hints+=STRING* 
	 *         answer=STRING 
	 *         script=Script?
	 *     )
	 */
	protected void sequence_Exercise_NotesElement(ISerializationContext context, Exercise semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FIB returns FIB
	 *     RTCElement returns FIB
	 *
	 * Constraint:
	 *     (hideFromView='hide'? question=STRING answers+=STRING+)
	 */
	protected void sequence_FIB(ISerializationContext context, FIB semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns FIB
	 *
	 * Constraint:
	 *     (hideFromView='hide'? question=STRING answers+=STRING+ script=Script?)
	 */
	protected void sequence_FIB_NotesElement(ISerializationContext context, FIB semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HotSpot returns HotSpot
	 *
	 * Constraint:
	 *     (x=INT y=INT label=STRING)
	 */
	protected void sequence_HotSpot(ISerializationContext context, HotSpot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.HOT_SPOT__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.HOT_SPOT__X));
			if (transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.HOT_SPOT__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.HOT_SPOT__Y));
			if (transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.HOT_SPOT__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.HOT_SPOT__LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHotSpotAccess().getXINTTerminalRuleCall_0_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getHotSpotAccess().getYINTTerminalRuleCall_2_0(), semanticObject.getY());
		feeder.accept(grammarAccess.getHotSpotAccess().getLabelSTRINGTerminalRuleCall_4_0(), semanticObject.getLabel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ImageLabel returns ImageLabel
	 *     RTCElement returns ImageLabel
	 *
	 * Constraint:
	 *     (hideFromView='hide'? caption=STRING? imageName=STRING hotspots+=HotSpot hotspots+=HotSpot*)
	 */
	protected void sequence_ImageLabel(ISerializationContext context, ImageLabel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns ImageLabel
	 *
	 * Constraint:
	 *     (
	 *         hideFromView='hide'? 
	 *         caption=STRING? 
	 *         imageName=STRING 
	 *         hotspots+=HotSpot 
	 *         hotspots+=HotSpot* 
	 *         script=Script?
	 *     )
	 */
	protected void sequence_ImageLabel_NotesElement(ISerializationContext context, ImageLabel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JoveNotes returns JoveNotes
	 *
	 * Constraint:
	 *     (processingHints=ProcessingHints chapterDetails=ChapterDetails notesElements+=NotesElement*)
	 */
	protected void sequence_JoveNotes(ISerializationContext context, JoveNotes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MatchMCQConfig returns MatchMCQConfig
	 *
	 * Constraint:
	 *     (forwardCaption=STRING reverseCaption=STRING? numOptionsToShow=INT? numOptionsPerRow=INT?)
	 */
	protected void sequence_MatchMCQConfig(ISerializationContext context, MatchMCQConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MatchPair returns MatchPair
	 *
	 * Constraint:
	 *     (matchQuestion=STRING matchAnswer=STRING)
	 */
	protected void sequence_MatchPair(ISerializationContext context, MatchPair semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.MATCH_PAIR__MATCH_QUESTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.MATCH_PAIR__MATCH_QUESTION));
			if (transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.MATCH_PAIR__MATCH_ANSWER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.MATCH_PAIR__MATCH_ANSWER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMatchPairAccess().getMatchQuestionSTRINGTerminalRuleCall_0_0(), semanticObject.getMatchQuestion());
		feeder.accept(grammarAccess.getMatchPairAccess().getMatchAnswerSTRINGTerminalRuleCall_2_0(), semanticObject.getMatchAnswer());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Matching returns Matching
	 *     RTCElement returns Matching
	 *
	 * Constraint:
	 *     (hideFromView='hide'? skipReverseQuestion='skip_reverse_question'? question=STRING? pairs+=MatchPair+ mcqConfig=MatchMCQConfig?)
	 */
	protected void sequence_Matching(ISerializationContext context, Matching semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns Matching
	 *
	 * Constraint:
	 *     (
	 *         hideFromView='hide'? 
	 *         skipReverseQuestion='skip_reverse_question'? 
	 *         question=STRING? 
	 *         pairs+=MatchPair+ 
	 *         mcqConfig=MatchMCQConfig? 
	 *         script=Script?
	 *     )
	 */
	protected void sequence_Matching_NotesElement(ISerializationContext context, Matching semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RTCElement returns MultiChoice
	 *     MultiChoice returns MultiChoice
	 *
	 * Constraint:
	 *     (
	 *         hideFromView='hide'? 
	 *         question=STRING 
	 *         options+=Option 
	 *         options+=Option* 
	 *         numOptionsToShow=INT? 
	 *         numOptionsPerRow=INT? 
	 *         explanation=STRING?
	 *     )
	 */
	protected void sequence_MultiChoice(ISerializationContext context, MultiChoice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns MultiChoice
	 *
	 * Constraint:
	 *     (
	 *         hideFromView='hide'? 
	 *         question=STRING 
	 *         options+=Option 
	 *         options+=Option* 
	 *         numOptionsToShow=INT? 
	 *         numOptionsPerRow=INT? 
	 *         explanation=STRING? 
	 *         script=Script?
	 *     )
	 */
	protected void sequence_MultiChoice_NotesElement(ISerializationContext context, MultiChoice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns QuestionAnswer
	 *
	 * Constraint:
	 *     (hideFromView='hide'? question=STRING answerParts+=STRING+ cmap=CMap? script=Script?)
	 */
	protected void sequence_NotesElement_QuestionAnswer(ISerializationContext context, QuestionAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns RefToContext
	 *
	 * Constraint:
	 *     (hideFromView='hide'? context=STRING rtcElement+=RTCElement+ script=Script?)
	 */
	protected void sequence_NotesElement_RefToContext(ISerializationContext context, RefToContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns Spellbee
	 *
	 * Constraint:
	 *     (hideFromView='hide'? word=STRING script=Script?)
	 */
	protected void sequence_NotesElement_Spellbee(ISerializationContext context, Spellbee semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns TeacherNote
	 *
	 * Constraint:
	 *     (hideFromView='hide'? caption=STRING? note=STRING cmap=CMap? script=Script?)
	 */
	protected void sequence_NotesElement_TeacherNote(ISerializationContext context, TeacherNote semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns TrueFalse
	 *
	 * Constraint:
	 *     (hideFromView='hide'? statement=STRING truthValue=BOOL justification=STRING? script=Script?)
	 */
	protected void sequence_NotesElement_TrueFalse(ISerializationContext context, TrueFalse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns VoiceToText
	 *
	 * Constraint:
	 *     (hideFromView='hide'? clipName=STRING text=STRING script=Script?)
	 */
	protected void sequence_NotesElement_VoiceToText(ISerializationContext context, VoiceToText semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NotesElement returns WordMeaning
	 *
	 * Constraint:
	 *     (hideFromView='hide'? word=STRING meaning=STRING script=Script?)
	 */
	protected void sequence_NotesElement_WordMeaning(ISerializationContext context, WordMeaning semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Option returns Option
	 *
	 * Constraint:
	 *     (optionValue=STRING correctOption='correct'?)
	 */
	protected void sequence_Option(ISerializationContext context, Option semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessingHints returns ProcessingHints
	 *
	 * Constraint:
	 *     (skipGeneration='@skip_generation'? skipGenerationInProduction='@skip_generation_in_production'?)
	 */
	protected void sequence_ProcessingHints(ISerializationContext context, ProcessingHints semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QuestionAnswer returns QuestionAnswer
	 *     RTCElement returns QuestionAnswer
	 *
	 * Constraint:
	 *     (hideFromView='hide'? question=STRING answerParts+=STRING+ cmap=CMap?)
	 */
	protected void sequence_QuestionAnswer(ISerializationContext context, QuestionAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RefToContext returns RefToContext
	 *
	 * Constraint:
	 *     (hideFromView='hide'? context=STRING rtcElement+=RTCElement+)
	 */
	protected void sequence_RefToContext(ISerializationContext context, RefToContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScriptBody returns ScriptBody
	 *
	 * Constraint:
	 *     script=STRING
	 */
	protected void sequence_ScriptBody(ISerializationContext context, ScriptBody semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.SCRIPT_BODY__SCRIPT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.SCRIPT_BODY__SCRIPT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScriptBodyAccess().getScriptSTRINGTerminalRuleCall_2_0(), semanticObject.getScript());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Script returns Script
	 *
	 * Constraint:
	 *     (evalVars+=EvalVar evalVars+=EvalVar* scriptBody=ScriptBody?)
	 */
	protected void sequence_Script(ISerializationContext context, Script semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Spellbee returns Spellbee
	 *
	 * Constraint:
	 *     (hideFromView='hide'? word=STRING)
	 */
	protected void sequence_Spellbee(ISerializationContext context, Spellbee semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TeacherNote returns TeacherNote
	 *     RTCElement returns TeacherNote
	 *
	 * Constraint:
	 *     (hideFromView='hide'? caption=STRING? note=STRING cmap=CMap?)
	 */
	protected void sequence_TeacherNote(ISerializationContext context, TeacherNote semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TrueFalse returns TrueFalse
	 *     RTCElement returns TrueFalse
	 *
	 * Constraint:
	 *     (hideFromView='hide'? statement=STRING truthValue=BOOL justification=STRING?)
	 */
	protected void sequence_TrueFalse(ISerializationContext context, TrueFalse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VoiceToText returns VoiceToText
	 *
	 * Constraint:
	 *     (hideFromView='hide'? clipName=STRING text=STRING)
	 */
	protected void sequence_VoiceToText(ISerializationContext context, VoiceToText semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordMeaning returns WordMeaning
	 *     RTCElement returns WordMeaning
	 *
	 * Constraint:
	 *     (hideFromView='hide'? word=STRING meaning=STRING)
	 */
	protected void sequence_WordMeaning(ISerializationContext context, WordMeaning semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
