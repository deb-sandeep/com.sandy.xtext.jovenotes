/*
 * generated by Xtext
 */
package com.sandy.xtext.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import com.sandy.xtext.joveNotes.CMap;
import com.sandy.xtext.joveNotes.ChapterDetails;
import com.sandy.xtext.joveNotes.ChemCompound;
import com.sandy.xtext.joveNotes.ChemEquation;
import com.sandy.xtext.joveNotes.Definition;
import com.sandy.xtext.joveNotes.EqSymbol;
import com.sandy.xtext.joveNotes.Equation;
import com.sandy.xtext.joveNotes.EvalVar;
import com.sandy.xtext.joveNotes.Event;
import com.sandy.xtext.joveNotes.FIB;
import com.sandy.xtext.joveNotes.HotSpot;
import com.sandy.xtext.joveNotes.ImageLabel;
import com.sandy.xtext.joveNotes.JoveNotes;
import com.sandy.xtext.joveNotes.JoveNotesPackage;
import com.sandy.xtext.joveNotes.MatchMCQConfig;
import com.sandy.xtext.joveNotes.MatchPair;
import com.sandy.xtext.joveNotes.Matching;
import com.sandy.xtext.joveNotes.MultiChoice;
import com.sandy.xtext.joveNotes.Option;
import com.sandy.xtext.joveNotes.ProcessingHints;
import com.sandy.xtext.joveNotes.QuestionAnswer;
import com.sandy.xtext.joveNotes.RefToContext;
import com.sandy.xtext.joveNotes.Script;
import com.sandy.xtext.joveNotes.ScriptBody;
import com.sandy.xtext.joveNotes.Spellbee;
import com.sandy.xtext.joveNotes.TeacherNote;
import com.sandy.xtext.joveNotes.TrueFalse;
import com.sandy.xtext.joveNotes.WordMeaning;
import com.sandy.xtext.services.JoveNotesGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class JoveNotesSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private JoveNotesGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == JoveNotesPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case JoveNotesPackage.CMAP:
				sequence_CMap(context, (CMap) semanticObject); 
				return; 
			case JoveNotesPackage.CHAPTER_DETAILS:
				sequence_ChapterDetails(context, (ChapterDetails) semanticObject); 
				return; 
			case JoveNotesPackage.CHARACTER:
				if(context == grammarAccess.getCharacterRule() ||
				   context == grammarAccess.getRTCElementRule()) {
					sequence_Character(context, (com.sandy.xtext.joveNotes.Character) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getNotesElementRule()) {
					sequence_Character_NotesElement(context, (com.sandy.xtext.joveNotes.Character) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.CHEM_COMPOUND:
				if(context == grammarAccess.getChemCompoundRule() ||
				   context == grammarAccess.getRTCElementRule()) {
					sequence_ChemCompound(context, (ChemCompound) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getNotesElementRule()) {
					sequence_ChemCompound_NotesElement(context, (ChemCompound) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.CHEM_EQUATION:
				if(context == grammarAccess.getChemEquationRule() ||
				   context == grammarAccess.getRTCElementRule()) {
					sequence_ChemEquation(context, (ChemEquation) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getNotesElementRule()) {
					sequence_ChemEquation_NotesElement(context, (ChemEquation) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.DEFINITION:
				if(context == grammarAccess.getDefinitionRule() ||
				   context == grammarAccess.getRTCElementRule()) {
					sequence_Definition(context, (Definition) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getNotesElementRule()) {
					sequence_Definition_NotesElement(context, (Definition) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.EQ_SYMBOL:
				sequence_EqSymbol(context, (EqSymbol) semanticObject); 
				return; 
			case JoveNotesPackage.EQUATION:
				if(context == grammarAccess.getEquationRule() ||
				   context == grammarAccess.getRTCElementRule()) {
					sequence_Equation(context, (Equation) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getNotesElementRule()) {
					sequence_Equation_NotesElement(context, (Equation) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.EVAL_VAR:
				sequence_EvalVar(context, (EvalVar) semanticObject); 
				return; 
			case JoveNotesPackage.EVENT:
				if(context == grammarAccess.getEventRule() ||
				   context == grammarAccess.getRTCElementRule()) {
					sequence_Event(context, (Event) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getNotesElementRule()) {
					sequence_Event_NotesElement(context, (Event) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.FIB:
				if(context == grammarAccess.getFIBRule() ||
				   context == grammarAccess.getRTCElementRule()) {
					sequence_FIB(context, (FIB) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getNotesElementRule()) {
					sequence_FIB_NotesElement(context, (FIB) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.HOT_SPOT:
				sequence_HotSpot(context, (HotSpot) semanticObject); 
				return; 
			case JoveNotesPackage.IMAGE_LABEL:
				if(context == grammarAccess.getImageLabelRule() ||
				   context == grammarAccess.getRTCElementRule()) {
					sequence_ImageLabel(context, (ImageLabel) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getNotesElementRule()) {
					sequence_ImageLabel_NotesElement(context, (ImageLabel) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.JOVE_NOTES:
				sequence_JoveNotes(context, (JoveNotes) semanticObject); 
				return; 
			case JoveNotesPackage.MATCH_MCQ_CONFIG:
				sequence_MatchMCQConfig(context, (MatchMCQConfig) semanticObject); 
				return; 
			case JoveNotesPackage.MATCH_PAIR:
				sequence_MatchPair(context, (MatchPair) semanticObject); 
				return; 
			case JoveNotesPackage.MATCHING:
				if(context == grammarAccess.getMatchingRule() ||
				   context == grammarAccess.getRTCElementRule()) {
					sequence_Matching(context, (Matching) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getNotesElementRule()) {
					sequence_Matching_NotesElement(context, (Matching) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.MULTI_CHOICE:
				if(context == grammarAccess.getMultiChoiceRule() ||
				   context == grammarAccess.getRTCElementRule()) {
					sequence_MultiChoice(context, (MultiChoice) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getNotesElementRule()) {
					sequence_MultiChoice_NotesElement(context, (MultiChoice) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.OPTION:
				sequence_Option(context, (Option) semanticObject); 
				return; 
			case JoveNotesPackage.PROCESSING_HINTS:
				sequence_ProcessingHints(context, (ProcessingHints) semanticObject); 
				return; 
			case JoveNotesPackage.QUESTION_ANSWER:
				if(context == grammarAccess.getNotesElementRule()) {
					sequence_NotesElement_QuestionAnswer(context, (QuestionAnswer) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getQuestionAnswerRule() ||
				   context == grammarAccess.getRTCElementRule()) {
					sequence_QuestionAnswer(context, (QuestionAnswer) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.REF_TO_CONTEXT:
				if(context == grammarAccess.getNotesElementRule()) {
					sequence_NotesElement_RefToContext(context, (RefToContext) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getRefToContextRule()) {
					sequence_RefToContext(context, (RefToContext) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.SCRIPT:
				sequence_Script(context, (Script) semanticObject); 
				return; 
			case JoveNotesPackage.SCRIPT_BODY:
				sequence_ScriptBody(context, (ScriptBody) semanticObject); 
				return; 
			case JoveNotesPackage.SPELLBEE:
				if(context == grammarAccess.getNotesElementRule()) {
					sequence_NotesElement_Spellbee(context, (Spellbee) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getRTCElementRule() ||
				   context == grammarAccess.getSpellbeeRule()) {
					sequence_Spellbee(context, (Spellbee) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.TEACHER_NOTE:
				if(context == grammarAccess.getNotesElementRule()) {
					sequence_NotesElement_TeacherNote(context, (TeacherNote) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getRTCElementRule() ||
				   context == grammarAccess.getTeacherNoteRule()) {
					sequence_TeacherNote(context, (TeacherNote) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.TRUE_FALSE:
				if(context == grammarAccess.getNotesElementRule()) {
					sequence_NotesElement_TrueFalse(context, (TrueFalse) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getRTCElementRule() ||
				   context == grammarAccess.getTrueFalseRule()) {
					sequence_TrueFalse(context, (TrueFalse) semanticObject); 
					return; 
				}
				else break;
			case JoveNotesPackage.WORD_MEANING:
				if(context == grammarAccess.getNotesElementRule()) {
					sequence_NotesElement_WordMeaning(context, (WordMeaning) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getRTCElementRule() ||
				   context == grammarAccess.getWordMeaningRule()) {
					sequence_WordMeaning(context, (WordMeaning) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     content=STRING
	 */
	protected void sequence_CMap(EObject context, CMap semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.CMAP__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.CMAP__CONTENT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCMapAccess().getContentSTRINGTerminalRuleCall_2_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         testPaper='@test_paper'? 
	 *         subjectName=STRING 
	 *         chapterNumber=INT 
	 *         subChapterNumber=INT 
	 *         chapterName=STRING 
	 *         scriptBody=ScriptBody?
	 *     )
	 */
	protected void sequence_ChapterDetails(EObject context, ChapterDetails semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? character=STRING estimate=STRING cmap=CMap?)
	 */
	protected void sequence_Character(EObject context, com.sandy.xtext.joveNotes.Character semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? character=STRING estimate=STRING cmap=CMap? script=Script?)
	 */
	protected void sequence_Character_NotesElement(EObject context, com.sandy.xtext.joveNotes.Character semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? symbol=STRING chemicalName=STRING commonName=STRING?)
	 */
	protected void sequence_ChemCompound(EObject context, ChemCompound semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? symbol=STRING chemicalName=STRING commonName=STRING? script=Script?)
	 */
	protected void sequence_ChemCompound_NotesElement(EObject context, ChemCompound semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? description=STRING? reactants=STRING produces=STRING? products=STRING)
	 */
	protected void sequence_ChemEquation(EObject context, ChemEquation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         hideFromView='hide'? 
	 *         description=STRING? 
	 *         reactants=STRING 
	 *         produces=STRING? 
	 *         products=STRING 
	 *         script=Script?
	 *     )
	 */
	protected void sequence_ChemEquation_NotesElement(EObject context, ChemEquation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? term=STRING definition=STRING cmap=CMap?)
	 */
	protected void sequence_Definition(EObject context, Definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? term=STRING definition=STRING cmap=CMap? script=Script?)
	 */
	protected void sequence_Definition_NotesElement(EObject context, Definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (symbol=STRING description=STRING)
	 */
	protected void sequence_EqSymbol(EObject context, EqSymbol semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.EQ_SYMBOL__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.EQ_SYMBOL__SYMBOL));
			if(transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.EQ_SYMBOL__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.EQ_SYMBOL__DESCRIPTION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEqSymbolAccess().getSymbolSTRINGTerminalRuleCall_0_0(), semanticObject.getSymbol());
		feeder.accept(grammarAccess.getEqSymbolAccess().getDescriptionSTRINGTerminalRuleCall_2_0(), semanticObject.getDescription());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? equation=STRING description=STRING? symbols+=EqSymbol symbols+=EqSymbol*)
	 */
	protected void sequence_Equation(EObject context, Equation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         hideFromView='hide'? 
	 *         equation=STRING 
	 *         description=STRING? 
	 *         symbols+=EqSymbol 
	 *         symbols+=EqSymbol* 
	 *         script=Script?
	 *     )
	 */
	protected void sequence_Equation_NotesElement(EObject context, Equation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (varName=STRING varExpression=STRING)
	 */
	protected void sequence_EvalVar(EObject context, EvalVar semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.EVAL_VAR__VAR_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.EVAL_VAR__VAR_NAME));
			if(transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.EVAL_VAR__VAR_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.EVAL_VAR__VAR_EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEvalVarAccess().getVarNameSTRINGTerminalRuleCall_0_0(), semanticObject.getVarName());
		feeder.accept(grammarAccess.getEvalVarAccess().getVarExpressionSTRINGTerminalRuleCall_2_0(), semanticObject.getVarExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? event=STRING time=STRING)
	 */
	protected void sequence_Event(EObject context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? event=STRING time=STRING script=Script?)
	 */
	protected void sequence_Event_NotesElement(EObject context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? question=STRING answers+=STRING+)
	 */
	protected void sequence_FIB(EObject context, FIB semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? question=STRING answers+=STRING+ script=Script?)
	 */
	protected void sequence_FIB_NotesElement(EObject context, FIB semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (x=INT y=INT label=STRING)
	 */
	protected void sequence_HotSpot(EObject context, HotSpot semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.HOT_SPOT__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.HOT_SPOT__X));
			if(transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.HOT_SPOT__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.HOT_SPOT__Y));
			if(transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.HOT_SPOT__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.HOT_SPOT__LABEL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getHotSpotAccess().getXINTTerminalRuleCall_0_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getHotSpotAccess().getYINTTerminalRuleCall_2_0(), semanticObject.getY());
		feeder.accept(grammarAccess.getHotSpotAccess().getLabelSTRINGTerminalRuleCall_4_0(), semanticObject.getLabel());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? caption=STRING? imageName=STRING hotspots+=HotSpot hotspots+=HotSpot*)
	 */
	protected void sequence_ImageLabel(EObject context, ImageLabel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         hideFromView='hide'? 
	 *         caption=STRING? 
	 *         imageName=STRING 
	 *         hotspots+=HotSpot 
	 *         hotspots+=HotSpot* 
	 *         script=Script?
	 *     )
	 */
	protected void sequence_ImageLabel_NotesElement(EObject context, ImageLabel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (processingHints=ProcessingHints chapterDetails=ChapterDetails notesElements+=NotesElement*)
	 */
	protected void sequence_JoveNotes(EObject context, JoveNotes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (forwardCaption=STRING reverseCaption=STRING? numOptionsToShow=INT? numOptionsPerRow=INT?)
	 */
	protected void sequence_MatchMCQConfig(EObject context, MatchMCQConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (matchQuestion=STRING matchAnswer=STRING)
	 */
	protected void sequence_MatchPair(EObject context, MatchPair semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.MATCH_PAIR__MATCH_QUESTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.MATCH_PAIR__MATCH_QUESTION));
			if(transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.MATCH_PAIR__MATCH_ANSWER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.MATCH_PAIR__MATCH_ANSWER));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMatchPairAccess().getMatchQuestionSTRINGTerminalRuleCall_0_0(), semanticObject.getMatchQuestion());
		feeder.accept(grammarAccess.getMatchPairAccess().getMatchAnswerSTRINGTerminalRuleCall_2_0(), semanticObject.getMatchAnswer());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? skipReverseQuestion='skip_reverse_question'? question=STRING? pairs+=MatchPair+ mcqConfig=MatchMCQConfig?)
	 */
	protected void sequence_Matching(EObject context, Matching semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         hideFromView='hide'? 
	 *         skipReverseQuestion='skip_reverse_question'? 
	 *         question=STRING? 
	 *         pairs+=MatchPair+ 
	 *         mcqConfig=MatchMCQConfig? 
	 *         script=Script?
	 *     )
	 */
	protected void sequence_Matching_NotesElement(EObject context, Matching semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         hideFromView='hide'? 
	 *         question=STRING 
	 *         options+=Option 
	 *         options+=Option* 
	 *         numOptionsToShow=INT? 
	 *         numOptionsPerRow=INT? 
	 *         explanation=STRING?
	 *     )
	 */
	protected void sequence_MultiChoice(EObject context, MultiChoice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         hideFromView='hide'? 
	 *         question=STRING 
	 *         options+=Option 
	 *         options+=Option* 
	 *         numOptionsToShow=INT? 
	 *         numOptionsPerRow=INT? 
	 *         explanation=STRING? 
	 *         script=Script?
	 *     )
	 */
	protected void sequence_MultiChoice_NotesElement(EObject context, MultiChoice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? question=STRING answerParts+=STRING+ cmap=CMap? script=Script?)
	 */
	protected void sequence_NotesElement_QuestionAnswer(EObject context, QuestionAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? context=STRING rtcElement+=RTCElement+ script=Script?)
	 */
	protected void sequence_NotesElement_RefToContext(EObject context, RefToContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? word=STRING script=Script?)
	 */
	protected void sequence_NotesElement_Spellbee(EObject context, Spellbee semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? caption=STRING? note=STRING cmap=CMap? script=Script?)
	 */
	protected void sequence_NotesElement_TeacherNote(EObject context, TeacherNote semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? statement=STRING truthValue=BOOL justification=STRING? script=Script?)
	 */
	protected void sequence_NotesElement_TrueFalse(EObject context, TrueFalse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? word=STRING meaning=STRING script=Script?)
	 */
	protected void sequence_NotesElement_WordMeaning(EObject context, WordMeaning semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (optionValue=STRING correctOption='correct'?)
	 */
	protected void sequence_Option(EObject context, Option semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (skipGeneration='@skip_generation'? skipGenerationInProduction='@skip_generation_in_production'?)
	 */
	protected void sequence_ProcessingHints(EObject context, ProcessingHints semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? question=STRING answerParts+=STRING+ cmap=CMap?)
	 */
	protected void sequence_QuestionAnswer(EObject context, QuestionAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? context=STRING rtcElement+=RTCElement+)
	 */
	protected void sequence_RefToContext(EObject context, RefToContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     script=STRING
	 */
	protected void sequence_ScriptBody(EObject context, ScriptBody semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, JoveNotesPackage.Literals.SCRIPT_BODY__SCRIPT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JoveNotesPackage.Literals.SCRIPT_BODY__SCRIPT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getScriptBodyAccess().getScriptSTRINGTerminalRuleCall_2_0(), semanticObject.getScript());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (evalVars+=EvalVar evalVars+=EvalVar* scriptBody=ScriptBody?)
	 */
	protected void sequence_Script(EObject context, Script semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? word=STRING)
	 */
	protected void sequence_Spellbee(EObject context, Spellbee semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? caption=STRING? note=STRING cmap=CMap?)
	 */
	protected void sequence_TeacherNote(EObject context, TeacherNote semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? statement=STRING truthValue=BOOL justification=STRING?)
	 */
	protected void sequence_TrueFalse(EObject context, TrueFalse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (hideFromView='hide'? word=STRING meaning=STRING)
	 */
	protected void sequence_WordMeaning(EObject context, WordMeaning semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
